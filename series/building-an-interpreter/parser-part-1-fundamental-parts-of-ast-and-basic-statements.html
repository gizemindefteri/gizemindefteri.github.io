<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="HandheldFriendly" content="True" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />
    <meta
      name="description"
      content="Build a parser and the fundamental parts of the Abstract Syntax Tree"
    />
    <meta
      name="keywords"
      content="javascript,typescript,pl_design,compiler,programming_language,interpreter"
    />
    <meta property="og:type" content="article" />
    <meta
      property="og:title"
      content="Parser - Part 1: Fundamental parts of AST and basic statements"
    />
    <meta
      property="og:description"
      content="Build a parser and the fundamental parts of the Abstract Syntax Tree"
    />
    <meta property="og:locale" content="en" />
    <meta
      property="og:image"
      content="https://leandrotk.github.io/series/building-an-interpreter/assets/fire.jpg"
    />
    <meta property="og:updated_time" content="2021-10-17T00:00:00.000Z" />
    <meta name="twitter:card" content="summary" />
    <meta
      name="twitter:title"
      content="Parser - Part 1: Fundamental parts of AST and basic statements"
    />
    <meta
      name="twitter:description"
      content="Build a parser and the fundamental parts of the Abstract Syntax Tree"
    />
    <meta
      name="twitter:image"
      content="https://leandrotk.github.io/series/building-an-interpreter/assets/fire.jpg"
    />

    <title>
      Parser - Part 1: Fundamental parts of AST and basic statements
    </title>
    <link rel="stylesheet" type="text/css" href="../../stylesheets/main.css" />
    <link
      rel="stylesheet"
      href="https://use.fontawesome.com/releases/v5.6.3/css/all.css"
      integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/"
      crossorigin="anonymous"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/styles/night-owl.min.css"
    />
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=UA-186262444-1"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag('js', new Date());
      gtag('config', 'UA-186262444-1');
    </script>
  </head>

  <body>
    <div class="content index width mx-auto px2 my4">
      <div id="header-post">
        <a id="menu-icon" href="../../index.html">
          <span class="fas fa-long-arrow-alt-left" />
        </a>
        <a id="menu-icon" href="../../index.html">
          <span>Anasayfa</span>
        </a>
      </div>
      <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
        <header>
          <h1 class="posttitle">
            Parser - Part 1: Fundamental parts of AST and basic statements
          </h1>
          <div class="meta">
            <span
              class="author"
              itemprop="author"
              itemscope
              itemtype="http://schema.org/Person"
            >
              <span itemprop="name">TK</span>
            </span>

            <div class="postdate">
              <time datetime="2021-10-17T00:00:00.000Z" itemprop="datePublished"
                >2021-10-17</time
              >
            </div>

            <div class="article-tag">
              <span class="fa fa-tag"></span>
              <a class="tag-link" href="../../tags/javascript.html"
                >javascript</a
              >
              <a class="tag-link" href="../../tags/typescript.html"
                >typescript</a
              >
              <a class="tag-link" href="../../tags/pl_design.html">pl_design</a>
            </div>
          </div>
        </header>

        <div class="figure">
          <img src="assets/fire.jpg" alt="Fire" />
          <span class="figcaption">
            Photo by
            <a href="https://unsplash.com/@andrewcoop" target="_blank"
              >Andrew Coop</a
            >
          </span>
        </div>

        <hr />

        <p>
          This post is part of a series called
          <a href="https://leandrotk.github.io/series/building-an-interpreter/"
            >Building an Interpreter</a
          >.
        </p>

        <p>
          Now that we implemented the
          <a
            href="https://leandrotk.github.io/series/building-an-interpreter/building-an-interpreter-lexical-analysis-part-1.html"
            >first steps of our lexer</a
          >,
          <a
            href="https://leandrotk.github.io/series/building-an-interpreter/building-an-interpreter-lexical-analysis-part-2.html"
            >more complex tokens</a
          >,
          <a
            href="https://leandrotk.github.io/series/building-an-interpreter/building-an-interpreter-lexical-analysis-part-3.html"
            >extended the token set with special characters</a
          >, and
          <a
            href="https://leandrotk.github.io/series/building-an-interpreter/building-an-interpreter-repl.html"
            >implemented a REPL</a
          >
          to print the tokens using our lexer, we want to start building the AST
          and the parser.
        </p>

        <blockquote>
          <p>
            "A parser is a software component that takes input data (frequently
            text) and builds a data structure – often some kind of parse tree,
            abstract syntax tree or other hierarchical structure – giving a
            structural representation of the input, checking for correct syntax
            in the process. […] The parser is often preceded by a separate
            lexical analyser, which creates tokens from the sequence of input
            characters." -
            <a href="https://en.wikipedia.org/wiki/Parsing">Wikipedia</a>
          </p>
        </blockquote>
        <p>
          So the idea of the parser will be to receive input data, can be text
          or tokens, and to produce a new data structure that represents this
          input data.
        </p>
        <p>
          The data structure the parsers produce is commonly called AST, or
          abstract syntax tree. It's called "abstract" because this data
          structure omits visible details of the source code like semicolons,
          newlines, whitespace, and so on.
        </p>
        <p>
          In the process of building this data structure, it also analyzes the
          source code, checking whether the generated tokens form a meaningful
          expression. This process is called <em>Syntactic Analysis</em>.
        </p>
        <p>
          Parsing JSON strings as an example. It transforms the string input
          into a data structure (JavaScript Object).
        </p>
        <pre><code class="typescript language-typescript">const input = '{"name": "TK", "age": 25}';
const output = JSON.parse(input);

output;
=&gt; { name: 'TK', age: 25 }

output.name;
=&gt; 'TK'

output.age;
=&gt; 25
</code></pre>
        <p>
          It also has the "syntactic analysis". When passing a "wrong" input
          data, it will throw a syntax error (<code>SyntaxError</code>):
        </p>
        <pre><code class="typescript language-typescript">const input = '{"name": "TK", 25}';
const output = JSON.parse(input);
=&gt; Uncaught SyntaxError: Unexpected number in JSON at position 15
</code></pre>
        <p>
          In this case, position 15 is the value <code>25</code>, where it is
          missing the attribute here.
        </p>
        <h2 id="fundamentalast">Fundamental AST</h2>
        <p>
          To parse the <code>Let Statement</code>, let's first understand its
          syntax.
        </p>
        <pre><code class="typescript language-typescript">let x = 10;
let y = 15;

let add = fn(a, b) {
  return a + b;
};
</code></pre>
        <p>
          Taking a closer look at this example, we can see a pattern here. All
          three statements have this same form:
        </p>
        <pre><code class="typescript language-typescript">let &lt;identifier&gt; = &lt;expression&gt;;
</code></pre>
        <p>
          So, in this case, it's easy to understand that <code>10</code>,
          <code>15</code>, and <code>fn</code> are expressions. The difference
          between statements and expressions is simple in this PL: expressions
          produce value, statements don't.
        </p>
        <p>
          And they are a fundamental part of the AST. Everything is a node in
          the tree, that can be a statement or an expression.
        </p>
        <pre><code class="typescript language-typescript">interface Node {
  tokenLiteral: () =&gt; string;
}
</code></pre>
        <p>
          The first step is to create this <code>Node</code> interface. Every
          node has to implement this <code>tokenLiteral</code> function.
          Meaning: every node has a token literal associated with it.
        </p>
        <pre><code class="typescript language-typescript">export interface Statement extends Node {}

export interface Expression extends Node {}
</code></pre>
        <p>
          The <code>Statement</code> and the <code>Expression</code> interfaces
          are built on top of the <code>Node</code> interface. Let's make it
          very simple now and improve later.
        </p>
        <p>
          The other fundamental part of the AST is the <code>Program</code>.
          It's the root node of the AST and it contains a list of statements.
        </p>
        <pre><code class="typescript language-typescript">export class Program {
  statements: Statement[] = [];
}
</code></pre>
        <h2 id="parsingtheletstatement">Parsing the let statement</h2>
        <p>
          Now that we have the foundation for our AST, we can build more
          specific statements. And we'll start with the
          <code>LetStatement</code>.
        </p>
        <p>
          <img
            src="./assets/ast-1.png"
            alt="AST with node, expression, statement, and the specific statements (return and let)"
          />
        </p>
        <p>
          This is how I'm visualizing the relationship between the
          <code>LetStatement</code> and the other interfaces.
        </p>
        <p>
          We start with "everything is a node". Then we have the two main
          interfaces: <code>Expression</code> and <code>Statement</code>. In
          this case, <code>LetStatement</code> implements the
          <code>Statement</code> interface.
        </p>
        <p>The <code>LetStatement</code> has these attributes:</p>
        <ul>
          <li>
            <code>token</code>: it has the type of the <code>Token</code> class
            we defined when we built the lexer. (just to refresh our memories,
            the <code>Token</code> has two attributes: the
            <code>type</code> (string) and <code>literal</code> (string). The
            <code>type</code> is any token we defined in the enum and the
            <code>literal</code> is the literal value of the token)
          </li>
          <li>
            <code>value</code>: it's an <code>Expression</code>. But we'll see
            more about this only in the next part of this series.
          </li>
          <li>
            <code>name</code>: it's an <code>Identifier</code> that has a
            <code>token</code> and a <code>value</code> as the attributes.
          </li>
        </ul>
        <p>To illustrate how it works in the code, let's see this example</p>
        <pre><code class="typescript language-typescript">let x = 1;
</code></pre>
        <p>
          The representation of the <code>LetStatement</code>'s AST would be:
        </p>
        <pre><code class="typescript language-typescript">LetStatement {
  token: Token { type: 'LET', literal: 'let' },
  name: Identifier {
    token: Token { type: 'IDENT', literal: 'x' },
    value: 'x'
  }
}
</code></pre>
        <p>
          We have the <code>token</code> that's the <code>LET</code> token and
          the <code>name</code> that's an <code>Identifier</code> with a token
          <code>IDENT</code> and the <code>value</code> as <code>'x'</code>. We
          won't cover the <code>value</code> attribute because we'll see this
          <code>Expression</code> in the next part of this series.
        </p>
        <p>
          With this in mind, we can create our <code>LetStatement</code> class:
        </p>
        <pre><code class="typescript language-typescript">class LetStatement implements Statement {
  token: Token;
  name: Identifier;
  value: Expression;

  constructor(token: Token) {
    this.token = token;
  }

  tokenLiteral() {
    return this.token.literal;
  }
}
</code></pre>
        <p>
          It has everything we already discussed, but we are missing the
          <code>Identifier</code> implementation:
        </p>
        <pre><code class="typescript language-typescript">class Identifier implements Expression {
  token: Token;
  value: string;

  constructor(token: Token, value: string) {
    this.token = token;
    this.value = value;
  }

  tokenLiteral() {
    return this.token.literal;
  }
}
</code></pre>
        <p>
          We also discussed this structure and what it should have: the
          <code>token</code> and the <code>value</code>.
        </p>
        <p>
          Now we have all the necessary AST nodes to start to implement the
          parser. But before we build the parser and start parsing the
          <code>LetStatement</code>, we'll add tests to cover this
          implementation first.
        </p>
        <pre><code class="typescript language-typescript">describe('Parser', () =&gt; {
  describe('parseProgram', () =&gt; {
    it('parses the let statement', () =&gt; {
      const input = `
        let x = 5;
        let y = 10;
        let foobar = 10000;
      `;

      const lexer = new Lexer(input);
      const parser = new Parser(lexer);
      const program = parser.parseProgram();

      const tests = [
        { identifier: 'x' },
        { identifier: 'y' },
        { identifier: 'foobar' },
      ];

      tests.forEach(({ identifier }, index) =&gt; {
        const statement = program.statements[index];

        expect(statement.tokenLiteral()).toEqual('let');
        expect(statement.name.value).toEqual(identifier);
                expect(statement.name.tokenLiteral()).toEqual(identifier);
      });
    });
  });
});
</code></pre>
        <p>We want the parser to parse this input</p>
        <pre><code class="typescript language-typescript">let x = 5;
let y = 10;
let foobar = 10000;
</code></pre>
        <p>
          First, we pass the <code>input</code> to the <code>Lexer</code> and
          then the <code>lexer</code> to the <code>Parser</code>. And now we can
          call the <code>parsePogram</code>. It'll return the
          <code>program</code> with all the <code>statements</code> related to
          the <code>input</code> data.
        </p>
        <p>What are we testing here?</p>
        <ul>
          <li>the statement token literal should be <code>'let'</code>.</li>
          <li>
            the identifier's value should the <code>identifier</code> we have in
            the <code>tests</code> array.
          </li>
          <li>
            and the token literal of the identifier should also be the
            <code>identifier</code>.
          </li>
        </ul>
        <p>
          Now we can start implementing the <code>Parser</code> and pass the
          tests. We start with the basic definition of the
          <code>Parser</code> class.
        </p>
        <pre><code class="typescript language-typescript">class Parser {
  private lexer: Lexer;
  private currentToken: Token;
  private peekToken: Token;

  constructor(lexer: Lexer) {
    this.lexer = lexer;
  }
}
</code></pre>
        <p>
          We need to make sure that the <code>lexer</code> is passed as a
          parameter and the parser should also have the:
        </p>
        <ul>
          <li><code>currentToken</code>: it is the token under examination</li>
          <li>
            <code>peekToken</code>: it is the next token that helps decide what
            to do next
          </li>
        </ul>
        <p>
          We'll also have a method called <code>nextToken</code> to update the
          <code>currentToken</code> and the <code>peekToken</code>:
        </p>
        <pre><code class="typescript language-typescript">nextToken() {
    this.currentToken = this.peekToken;
  this.peekToken = this.lexer.nextToken();
}
</code></pre>
        <p>
          And to initialize these two states, we can call this method two times
          in the constructor. Calling two times will set the correct state for
          the current and the next tokens. It looks like this:
        </p>
        <pre><code class="typescript language-typescript">constructor(lexer: Lexer) {
  this.lexer = lexer;
  this.nextToken();
  this.nextToken();
}
</code></pre>
        <p>
          Now the <code>parseProgram</code>. The idea of this method is to
          create a program and parse each statement based on the tokens and add
          all the statements to the statements list in the program.
        </p>
        <pre><code class="typescript language-typescript">parseProgram() {
  const program = new Program();

  while (this.currentToken.type !== Tokens.EOF) {
    const statement = this.parseStatement();

    if (statement !== null) {
      program.statements.push(statement);
    }

    this.nextToken();
  }

  return program;
}
</code></pre>
        <p>
          It iterates through all the tokens from the lexer, for each token,
          it'll parse the statement and add it to the statements list. And in
          the end, it'll just return the program.
        </p>
        <p>
          From this code, we need to implement this
          <code>parseStatement</code> method.
        </p>
        <pre><code class="typescript language-typescript">private parseLetStatement() {
  const statement = new LetStatement(this.currentToken);

  if (!this.expectPeek(Tokens.IDENT)) {
    return null;
  }

  const identifier = new Identifier(
    this.currentToken,
    this.currentToken.literal
  );

  statement.name = identifier;

  if (!this.expectPeek(Tokens.ASSIGN)) {
    return null;
  }

  while (!this.currentTokenIs(Tokens.SEMICOLON)) {
    this.nextToken();
  }

  return statement;
}
</code></pre>
        <p>
          I think this first implementation is not the best one, but we can
          refactor it later (I have some ideas in mind that I want to try
          later).
        </p>
        <ul>
          <li>
            The first thing is to create a new <code>LetStatement</code> based
            on the current token
          </li>
          <li>
            Then we need to confirm that the next token is an
            <code>Identifier</code>. If it's, we call <code>nextToken</code> to
            update the state of the <code>currentToken</code> and the
            <code>peekToken</code>. If not, we just return
            <code>null</code> (just to simplify for now).
          </li>
          <li>
            Then we move to create the identifier. We just pass the current
            token and the current token's literal and update the statement name
            with this new identifier.
          </li>
          <li>
            We expect that the next token is a <code>=</code> token
            (<code>ASSIGN</code>).
          </li>
          <li>
            <em><strong>TODO</strong>:</em> implement the expression/value in
            the next post of this series
          </li>
          <li>
            After that, we just go through all the tokens until we find the
            <code>;</code> token and return the new statement.
          </li>
        </ul>
        <p>
          This new statement will be used to add it to the statements list in
          the program. But we are missing two important methods here:
          <code>expectPeek</code> and <code>currentTokenIs</code>. Let's
          implement them.
        </p>
        <pre><code class="typescript language-typescript">private currentTokenIs(token: TokenType) {
  return this.currentToken.type === token;
}
</code></pre>
        <p>
          <code>currentTokenIs</code> is a simple method to verify if the
          current token has the same token type that we expect it has.
        </p>
        <pre><code class="typescript language-typescript">private peekTokenIs(token: TokenType) {
  return this.peekToken.type === token;
}

private expectPeek(token: TokenType) {
  if (this.peekTokenIs(token)) {
    this.nextToken();
    return true;
  }

  return false;
}
</code></pre>
        <p>
          The <code>expectPeek</code> method will use the
          <code>peekTokenIs</code> (that's very similar to the
          <code>currentTokenIs</code>, but for the <code>peekToken</code>) to
          verify if the token is the expected one. If it is, we update the
          current and the next token and return true. If not just return false
          (we'll also add error handling soon).
        </p>
        <p>
          Now we have the parser, the program, and we can parse let statements
          making the tests pass.
        </p>
        <h2 id="handlingerrors">Handling errors</h2>
        <p>
          For this input data <code>let x = 5;</code>, we don't have any syntax
          problem, so we won't have any error to handle. But imagine the PL user
          type this:
        </p>
        <pre><code class="typescript language-typescript">let 123;
let a;
</code></pre>
        <p>
          There's a syntax error. Because, for a let statement, we expect that
          after the <code>let</code> token, we get an identifier, not the
          value/expression. And for the second example, after having the
          identifier, the parser expects that it has <code>=</code> token.
        </p>
        <p>We could output something like this to the user:</p>
        <pre><code class="typescript language-typescript">let 123;
=&gt; 'expected next token to be IDENT, got INT instead'

let a;
=&gt; 'expected next token to be =, got ; instead'
</code></pre>
        <p>
          Errors are ways to communicate to the users about what they are
          writing and help them get to the final goal (a "working software").
        </p>
        <p>
          But how do we do that? Let's start with the tests as we always do.
        </p>
        <pre><code class="typescript language-typescript">it('parses an input with error', () =&gt; {
  const input = `
    let 123;
    let a;
  `;

  const lexer = new Lexer(input);
  const parser = new Parser(lexer);

  parser.parseProgram();

  const errors = parser.getErrors();
  const expectedErrors = [
    'expected next token to be IDENT, got INT instead',
    'expected next token to be =, got ; instead',
  ];

  errors.forEach((error, index) =&gt; {
    expect(error).toEqual(expectedErrors[index]);
  });
});
</code></pre>
        <p>
          Here we have the input data that we talked about. But now we'll also
          have a <code>getErrors</code> method to get all the possible errors
          the parser had while parsing the input.
        </p>
        <p>
          And we expect that the parser has these two errors we already
          discussed.
        </p>
        <p>
          Ok, to have all the errors, let's create a list of errors in the
          parser.
        </p>
        <pre><code class="typescript language-typescript">type Error = string;

class Parser {
  private lexer: Lexer;
  private currentToken: Token;
  private peekToken: Token;
  private errors: Error[];

  constructor(lexer: Lexer) {
    this.lexer = lexer;
    this.errors = [];
    this.nextToken();
    this.nextToken();
  }
}
</code></pre>
        <p>
          It's very simple, it's just a private attribute from the class
          <code>Parser</code>, it has the type <code>Error</code> (that's a
          <code>string</code>), and we initialize it with an empty list.
        </p>
        <p>
          The <code>getErrors</code> method will only return the errors
          attribute:
        </p>
        <pre><code class="typescript language-typescript">getErrors() {
  return this.errors;
}
</code></pre>
        <p>
          And now what we need to do is to add a error message when the parser
          gets an error.
        </p>
        <p>
          In this case, we'll add an error to the list when the next token it's
          not the expected one, so the place we do that is in the
          <code>expectPeek</code> method.
        </p>
        <pre><code class="typescript language-typescript">private expectPeek(token: TokenType) {
  if (this.peekTokenIs(token)) {
    this.nextToken();
    return true;
  }

  this.peekError(token);
  return false;
}
</code></pre>
        <p>
          When the next token is not the expected one, we call the
          <code>peekError</code> method passing the expected token to it. Now
          let's implement this new method:
        </p>



<footer id="footer">
  <div class="footer-left">Copyright &copy; 2021</div>
  <div class="footer-right">
    <nav>
      <ul>
        <li><a href="index.html">Anasayfa</a></li>
        <li><a href="quotes.html">Quotes</a></li>
        <li><a href="fotoğraflar.html">Fotoğraflar</a></li>
      </ul>
    </nav>
  </div>
</footer>

    <script src="../../javascripts/highlight.pack.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
  </body>
</html>
